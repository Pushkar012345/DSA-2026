## ğŸ—‘ï¸ Delete Middle Node of Linked List

**Two Pointer Approach | Beginner Friendly | Dry Run | O(n) Time | O(1) Space**

---

# âœ… Intuition ğŸ‘ˆ

We are given a **singly linked list**, and we need to **remove the middle node**.

* If the list length is **odd** â†’ remove the exact middle node.
* If the list length is **even** â†’ remove the **first middle node** (as per this approach).

To do this efficiently in **one traversal**, we use the **Two Pointer (Fast & Slow) Technique**.

---

# ğŸš€ Approach (Two Pointer Technique) ğŸ‘ˆ

### ğŸ”¹ Key Idea

* Use two pointers:

  * `slow` â†’ moves **1 step**
  * `fast` â†’ moves **2 steps**

By the time `fast` reaches the end:

* `slow` will be **just before the middle node**

So we can easily remove the middle node by:

```
slow.next = slow.next.next
```

---

### ğŸ”¹ Why Dummy Node?

We create a **dummy node (`prev`)** before `head` because:

* It helps handle edge cases easily.
* Especially when list has only 1 node.
* Avoids special handling for deleting first node.

---

# ğŸ’» JavaScript Code (Clean & Proper)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteMiddle = function(head) {
    
    // Base Case: If list is empty or has only one node
    if (head === null || head.next === null) {
        return null;
    }

    // Create dummy node
    let prev = new ListNode(0);
    prev.next = head;

    let slow = prev;
    let fast = head;

    // Move fast by 2 steps and slow by 1 step
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Remove middle node
    slow.next = slow.next.next;

    return prev.next;
};
```

---

# ğŸ§ª Dry Run ğŸ‘ˆ

### Example List:

```
1 â†’ 3 â†’ 4 â†’ 7 â†’ 1 â†’ 2 â†’ 6
```

---

### ğŸ”¹ Step 1: Initialization

```
prev â†’ 0(dummy)
         â†“
1 â†’ 3 â†’ 4 â†’ 7 â†’ 1 â†’ 2 â†’ 6
```

* `slow = prev`
* `fast = head (1)`

---

### ğŸ”¹ Step 2: Iterations

| Iteration | slow moves to            | fast moves to |
| --------- | ------------------------ | ------------- |
| 1st       | 1                        | 4             |
| 2nd       | 3                        | 1             |
| 3rd       | 4                        | 6             |
| Next      | fast becomes null â†’ stop |               |

Now:

```
slow â†’ 4
slow.next â†’ 7 (Middle Node)
```

---

### ğŸ”¹ Step 3: Delete Middle

```
slow.next = slow.next.next
```

So:

```
4 â†’ 1
```

New List:

```
1 â†’ 3 â†’ 4 â†’ 1 â†’ 2 â†’ 6
```

âœ… Middle node (7) removed.

---

# â± Time Complexity ğŸ‘ˆ

* We traverse the list **only once**
* Each node visited at most once

ğŸ‘‰ **Time Complexity = O(n)**

---

# ğŸ§  Space Complexity ğŸ‘ˆ

* No extra data structure used
* Only few pointers

ğŸ‘‰ **Space Complexity = O(1)**

---

# ğŸ¯ Why This is Efficient?

âœ” Single traversal
âœ” No extra memory
âœ” Handles edge cases
âœ” Clean & readable

---

If you want, I can also give:

* ğŸ”¥ Without Dummy Node version
* ğŸ”¥ For deleting second middle node
* ğŸ”¥ Step-by-step pointer diagram visualization
* ğŸ”¥ Interview explanation format

Just tell me ğŸš€
