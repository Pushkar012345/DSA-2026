## Odd-Even Linked List (In-Place Reordering)

### ğŸ§  Intuition

We are given a singly linked list and need to:

* Group all **odd index nodes** together
* Followed by all **even index nodes**

ğŸ‘‰ Important:

* Indexing is **1-based** (not 0-based).
* We must **rearrange nodes**, not values.
* No extra space allowed â€” only pointer manipulation.

Instead of creating new lists, we can:

* Maintain two pointers:

  * `odd` â†’ tracks odd-indexed nodes
  * `even` â†’ tracks even-indexed nodes
* Rearrange the `next` pointers in one traversal.

---

### ğŸš€ Approach (Step-by-Step)

1. **Edge Case Check**

   * If list is empty or has only one node â†’ return head.

2. **Initialize Pointers**

   * `odd = head`
   * `even = head.next`
   * Store `evenHead = even` (so we can attach even list later)

3. **Traverse the List**

   * While `even` and `even.next` exist:

     * Connect odd to next odd â†’ `odd.next = even.next`
     * Move odd forward â†’ `odd = odd.next`
     * Connect even to next even â†’ `even.next = odd.next`
     * Move even forward â†’ `even = even.next`

4. **Attach Even List**

   * After loop ends, connect last odd node to `evenHead`

---

### ğŸ” Dry Run Example

Input:

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
```

Initial:

```
odd = 1
even = 2
evenHead = 2
```

### Iteration 1:

```
odd.next = 3
odd = 3

even.next = 4
even = 4
```

List now:

```
1 â†’ 3 â†’ 4 â†’ 5
2 â†’ 4
```

### Iteration 2:

```
odd.next = 5
odd = 5

even.next = null
even = null
```

Final Step:

```
5.next = 2
```

Final Output:

```
1 â†’ 3 â†’ 5 â†’ 2 â†’ 4
```

---

### â± Complexity Analysis

* **Time Complexity:** `O(n)`
  â†’ Single traversal of the list.

* **Space Complexity:** `O(1)`
  â†’ Only pointer variables used.

---

### ğŸ’» Clean JavaScript Code

```javascript
function oddEvenList(head) {
    // Edge case: empty list or single node
    if (!head || !head.next) return head;

    let odd = head;              // Start of odd list
    let even = head.next;        // Start of even list
    const evenHead = even;       // Store even list head

    // Rearrange nodes
    while (even && even.next) {
        odd.next = even.next;    // Link odd to next odd
        odd = odd.next;          // Move odd pointer

        even.next = odd.next;    // Link even to next even
        even = even.next;        // Move even pointer
    }

    // Attach even list at the end of odd list
    odd.next = evenHead;

    return head;
}
```

---

### ğŸ¯ Why This Is Clean

âœ” No extra data structures
âœ” No dummy nodes
âœ” Only pointer rewiring
âœ” Single pass solution

This is one of the most elegant pointer manipulation tricks in Linked List problems.

